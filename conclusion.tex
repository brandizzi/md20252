

This paper examined the challenges of auto-scaling containerized Java applications in Kubernetes, focusing on Liferay DXP. We highlighted two key issues: the inadequacy of standard HPA metrics—particularly memory usage—as indicators of application health, and the long startup times of Java-based applications. To address these, it was explored the use of more reliable JVM-based metrics with some time series analysis algorithms.

The proposal was to see the performance of every algorithm compared to others, and it gave instructive results. Simpler algorithms, such as Moving Average and Auto-regression, alone, were the worst. ARMA and ARIMA worked well. SARIMA, which could capture seasonal patterns, performed worse than the least general ARMA and ARIMA, but it used seasonal hyperparameters that were not natural.

One way or ther other, all models performed quite badly: none even yielded a positive $R^2$. But the difference of performance between them is still instructitive.

For future work, many possibilities are open. An immediate one is an exploration of better  hyperparameters for the various models. It is especially necessary for the seasonal orders of SARIMA, but even ARMA and ARIMA could be improved.

Another natural step is to incorporate exogenous factors. The paper only uses historical JVM memory usage to forecast future values, but other metrics are available, in principle: CPU usage, busy threads, HTTP request count etc. None of those were used because the authors lacked the permission for their uses, but once acquired, it will open the opportunity to explore other, more powerful algorithms such as ARIMAX and SARIMAX.

Naturally, it is possible to work with transformed values. A very common one is the log of the memory usage, since it can alleviate drastic oscillations. Another interesting appraoch is to model seasonalities not with the hyperparameters of SARIMA(X), but by creating exogenous factors with transformations. For example, by adding a column with values varying according to a sine function, we can define when we want some values to relate to others by defining the period of the sine function.

Overall, the use of internal JVM mermoy proved to be better than monitoring the pod memory, because it is more responsive. The challenge relies in finding the best model. Time series analysys models were underperforming, although in different levels. Nonetheless, the next steps are experimenting with different hyperparameters, exogenous values and transformed values. While TSA didn't yield good results, this is only a prelimitary experimentation and there are many ways to explore these tools yet.